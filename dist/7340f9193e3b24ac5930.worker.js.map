{"version":3,"sources":["webpack:///7340f9193e3b24ac5930.worker.js","webpack:///webpack/bootstrap 7340f9193e3b24ac5930","webpack:///./src/lib/gif.worker.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","LZWEncoder","width","height","pixels","colorDepth","char_out","outs","accum","a_count","flush_char","cl_block","cl_hash","HSIZE","free_ent","ClearCode","clear_flg","output","hsize","htab","compress","init_bits","fcode","ent","disp","hsize_reg","hshift","g_init_bits","n_bits","maxcode","MAXCODE","EOFCode","nextPixel","outer_loop","EOF","BITS","codetab","encode","writeByte","initCodeSize","remaining","curPixel","writeBytes","code","cur_accum","masks","cur_bits","Math","max","Uint8Array","Int32Array","this","NeuQuant","samplefac","init","network","netindex","bias","netsize","freq","radpower","v","netbiasshift","Float64Array","intbias","unbiasnet","altersingle","alpha","b","g","r","initalpha","alterneigh","radius","a","lo","abs","hi","min","j","k","alpharadbias","contest","dist","biasdist","betafreq","bestd","bestbiasd","bestpos","bestbiaspos","intbiasshift","betashift","gammashift","beta","betagamma","inxbuild","q","smallpos","smallval","previouscol","startpos","maxnetpos","inxsearch","best","learn","lengthcount","length","alphadec","samplepixels","delta","ncycles","initradius","rad","radiusbiasshift","radbias","step","minpicturebytes","prime1","prime2","prime3","prime4","pix","radiusdec","buildColormap","getColormap","map","index","lookupRGB","ByteArray","page","pages","newPage","GIFEncoder","transparent","transIndex","repeat","delay","image","indexedPixels","colorTab","neuQuant","usedEntry","Array","palSize","dispose","firstFrame","sample","dither","globalPalette","out","renderFrame","initrad","radiusbias","alphabiasshift","frame","encoder","stream","transfer","writeHeader","setTransparent","setRepeat","setDelay","setQuality","quality","setDither","setGlobalPalette","addFrame","data","last","finish","getGlobalPalette","cursor","pageSize","constructor","canTransfer","len","ref","results","push","buffer","self","postMessage","onmessage","event","charMap","String","fromCharCode","getData","rv","val","writeUTFBytes","string","charCodeAt","array","offset","milliseconds","round","setFrameRate","fps","setDispose","disposalCode","color","imageData","slice","getImagePixels","analyzePixels","writeLSD","writePalette","writeNetscapeExt","writeGraphicCtrlExt","writeImageDesc","writePixels","palette","ditherPixels","replace","match","indexPixels","findClosest","imgq","nPix","findClosestRGB","kernel","serpentine","kernels","FalseFloydSteinberg","FloydSteinberg","Stucki","Atkinson","ds","direction","y","x","xend","idx","r1","g1","b1","r2","g2","b2","er","eg","eb","end","x1","y1","used","minpos","dmin","dr","dg","db","w","h","srcPos","count","transp","writeShort","pValue"],"mappings":"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","file":"7340f9193e3b24ac5930.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\n~function () {\n  var EOF = -1;\n  var BITS = 12;\n  var HSIZE = 5003;\n  var masks = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535];\n  var remaining, curPixel, n_bits;\n  function LZWEncoder(width, height, pixels, colorDepth) {\n    var initCodeSize = Math.max(2, colorDepth);\n    var accum = new Uint8Array(256);\n    var htab = new Int32Array(HSIZE);\n    var codetab = new Int32Array(HSIZE);\n    var cur_accum,\n        cur_bits = 0;\n    var a_count;\n    var free_ent = 0;\n    var maxcode;\n    var clear_flg = false;\n    var g_init_bits, ClearCode, EOFCode;\n    function char_out(c, outs) {\n      accum[a_count++] = c;\n      if (a_count >= 254) flush_char(outs);\n    }\n    function cl_block(outs) {\n      cl_hash(HSIZE);\n      free_ent = ClearCode + 2;\n      clear_flg = true;\n      output(ClearCode, outs);\n    }\n    function cl_hash(hsize) {\n      for (var i = 0; i < hsize; ++i) {\n        htab[i] = -1;\n      }\n    }\n    function compress(init_bits, outs) {\n      var fcode, c, i, ent, disp, hsize_reg, hshift;\n      g_init_bits = init_bits;\n      clear_flg = false;\n      n_bits = g_init_bits;\n      maxcode = MAXCODE(n_bits);\n      ClearCode = 1 << init_bits - 1;\n      EOFCode = ClearCode + 1;\n      free_ent = ClearCode + 2;\n      a_count = 0;\n      ent = nextPixel();\n      hshift = 0;\n      for (fcode = HSIZE; fcode < 65536; fcode *= 2) {\n        ++hshift;\n      }hshift = 8 - hshift;\n      hsize_reg = HSIZE;\n      cl_hash(hsize_reg);\n      output(ClearCode, outs);\n      outer_loop: while ((c = nextPixel()) != EOF) {\n        fcode = (c << BITS) + ent;\n        i = c << hshift ^ ent;\n        if (htab[i] === fcode) {\n          ent = codetab[i];\n          continue;\n        } else if (htab[i] >= 0) {\n          disp = hsize_reg - i;\n          if (i === 0) disp = 1;\n          do {\n            if ((i -= disp) < 0) i += hsize_reg;\n            if (htab[i] === fcode) {\n              ent = codetab[i];\n              continue outer_loop;\n            }\n          } while (htab[i] >= 0);\n        }\n        output(ent, outs);\n        ent = c;\n        if (free_ent < 1 << BITS) {\n          codetab[i] = free_ent++;\n          htab[i] = fcode;\n        } else {\n          cl_block(outs);\n        }\n      }\n      output(ent, outs);\n      output(EOFCode, outs);\n    }\n    function encode(outs) {\n      outs.writeByte(initCodeSize);\n      remaining = width * height;\n      curPixel = 0;\n      compress(initCodeSize + 1, outs);\n      outs.writeByte(0);\n    }\n    function flush_char(outs) {\n      if (a_count > 0) {\n        outs.writeByte(a_count);\n        outs.writeBytes(accum, 0, a_count);\n        a_count = 0;\n      }\n    }\n    function MAXCODE(n_bits) {\n      return (1 << n_bits) - 1;\n    }\n    function nextPixel() {\n      if (remaining === 0) return EOF;\n      --remaining;\n      var pix = pixels[curPixel++];\n      return pix & 255;\n    }\n    function output(code, outs) {\n      cur_accum &= masks[cur_bits];\n      if (cur_bits > 0) cur_accum |= code << cur_bits;else cur_accum = code;\n      cur_bits += n_bits;\n      while (cur_bits >= 8) {\n        char_out(cur_accum & 255, outs);\n        cur_accum >>= 8;\n        cur_bits -= 8;\n      }\n      if (free_ent > maxcode || clear_flg) {\n        if (clear_flg) {\n          maxcode = MAXCODE(n_bits = g_init_bits);\n          clear_flg = false;\n        } else {\n          ++n_bits;\n          if (n_bits == BITS) maxcode = 1 << BITS;else maxcode = MAXCODE(n_bits);\n        }\n      }\n      if (code == EOFCode) {\n        while (cur_bits > 0) {\n          char_out(cur_accum & 255, outs);\n          cur_accum >>= 8;\n          cur_bits -= 8;\n        }\n        flush_char(outs);\n      }\n    }\n    this.encode = encode;\n  }\n  var ncycles = 100;\n  var netsize = 256;\n  var maxnetpos = netsize - 1;\n  var netbiasshift = 4;\n  var intbiasshift = 16;\n  var intbias = 1 << intbiasshift;\n  var gammashift = 10;\n  var gamma = 1 << gammashift;\n  var betashift = 10;\n  var beta = intbias >> betashift;\n  var betagamma = intbias << gammashift - betashift;\n  var initrad = netsize >> 3;\n  var radiusbiasshift = 6;\n  var radiusbias = 1 << radiusbiasshift;\n  var initradius = initrad * radiusbias;\n  var radiusdec = 30;\n  var alphabiasshift = 10;\n  var initalpha = 1 << alphabiasshift;\n  var alphadec;\n  var radbiasshift = 8;\n  var radbias = 1 << radbiasshift;\n  var alpharadbshift = alphabiasshift + radbiasshift;\n  var alpharadbias = 1 << alpharadbshift;\n  var prime1 = 499;\n  var prime2 = 491;\n  var prime3 = 487;\n  var prime4 = 503;\n  var minpicturebytes = 3 * prime4;\n  function NeuQuant(pixels, samplefac) {\n    var network;\n    var netindex;\n    var bias;\n    var freq;\n    var radpower;\n    function init() {\n      network = [];\n      netindex = new Int32Array(256);\n      bias = new Int32Array(netsize);\n      freq = new Int32Array(netsize);\n      radpower = new Int32Array(netsize >> 3);\n      var i, v;\n      for (i = 0; i < netsize; i++) {\n        v = (i << netbiasshift + 8) / netsize;\n        network[i] = new Float64Array([v, v, v, 0]);\n        freq[i] = intbias / netsize;\n        bias[i] = 0;\n      }\n    }\n    function unbiasnet() {\n      for (var i = 0; i < netsize; i++) {\n        network[i][0] >>= netbiasshift;\n        network[i][1] >>= netbiasshift;\n        network[i][2] >>= netbiasshift;\n        network[i][3] = i;\n      }\n    }\n    function altersingle(alpha, i, b, g, r) {\n      network[i][0] -= alpha * (network[i][0] - b) / initalpha;\n      network[i][1] -= alpha * (network[i][1] - g) / initalpha;\n      network[i][2] -= alpha * (network[i][2] - r) / initalpha;\n    }\n    function alterneigh(radius, i, b, g, r) {\n      var lo = Math.abs(i - radius);\n      var hi = Math.min(i + radius, netsize);\n      var j = i + 1;\n      var k = i - 1;\n      var m = 1;\n      var p, a;\n      while (j < hi || k > lo) {\n        a = radpower[m++];\n        if (j < hi) {\n          p = network[j++];\n          p[0] -= a * (p[0] - b) / alpharadbias;\n          p[1] -= a * (p[1] - g) / alpharadbias;\n          p[2] -= a * (p[2] - r) / alpharadbias;\n        }\n        if (k > lo) {\n          p = network[k--];\n          p[0] -= a * (p[0] - b) / alpharadbias;\n          p[1] -= a * (p[1] - g) / alpharadbias;\n          p[2] -= a * (p[2] - r) / alpharadbias;\n        }\n      }\n    }\n    function contest(b, g, r) {\n      var bestd = ~(1 << 31);\n      var bestbiasd = bestd;\n      var bestpos = -1;\n      var bestbiaspos = bestpos;\n      var i, n, dist, biasdist, betafreq;\n      for (i = 0; i < netsize; i++) {\n        n = network[i];\n        dist = Math.abs(n[0] - b) + Math.abs(n[1] - g) + Math.abs(n[2] - r);\n        if (dist < bestd) {\n          bestd = dist;\n          bestpos = i;\n        }\n        biasdist = dist - (bias[i] >> intbiasshift - netbiasshift);\n        if (biasdist < bestbiasd) {\n          bestbiasd = biasdist;\n          bestbiaspos = i;\n        }\n        betafreq = freq[i] >> betashift;\n        freq[i] -= betafreq;\n        bias[i] += betafreq << gammashift;\n      }\n      freq[bestpos] += beta;\n      bias[bestpos] -= betagamma;\n      return bestbiaspos;\n    }\n    function inxbuild() {\n      var i,\n          j,\n          p,\n          q,\n          smallpos,\n          smallval,\n          previouscol = 0,\n          startpos = 0;\n      for (i = 0; i < netsize; i++) {\n        p = network[i];\n        smallpos = i;\n        smallval = p[1];\n        for (j = i + 1; j < netsize; j++) {\n          q = network[j];\n          if (q[1] < smallval) {\n            smallpos = j;\n            smallval = q[1];\n          }\n        }\n        q = network[smallpos];\n        if (i != smallpos) {\n          j = q[0];\n          q[0] = p[0];\n          p[0] = j;\n          j = q[1];\n          q[1] = p[1];\n          p[1] = j;\n          j = q[2];\n          q[2] = p[2];\n          p[2] = j;\n          j = q[3];\n          q[3] = p[3];\n          p[3] = j;\n        }\n        if (smallval != previouscol) {\n          netindex[previouscol] = startpos + i >> 1;\n          for (j = previouscol + 1; j < smallval; j++) {\n            netindex[j] = i;\n          }previouscol = smallval;\n          startpos = i;\n        }\n      }\n      netindex[previouscol] = startpos + maxnetpos >> 1;\n      for (j = previouscol + 1; j < 256; j++) {\n        netindex[j] = maxnetpos;\n      }\n    }\n    function inxsearch(b, g, r) {\n      var a, p, dist;\n      var bestd = 1e3;\n      var best = -1;\n      var i = netindex[g];\n      var j = i - 1;\n      while (i < netsize || j >= 0) {\n        if (i < netsize) {\n          p = network[i];\n          dist = p[1] - g;\n          if (dist >= bestd) i = netsize;else {\n            i++;\n            if (dist < 0) dist = -dist;\n            a = p[0] - b;\n            if (a < 0) a = -a;\n            dist += a;\n            if (dist < bestd) {\n              a = p[2] - r;\n              if (a < 0) a = -a;\n              dist += a;\n              if (dist < bestd) {\n                bestd = dist;\n                best = p[3];\n              }\n            }\n          }\n        }\n        if (j >= 0) {\n          p = network[j];\n          dist = g - p[1];\n          if (dist >= bestd) j = -1;else {\n            j--;\n            if (dist < 0) dist = -dist;\n            a = p[0] - b;\n            if (a < 0) a = -a;\n            dist += a;\n            if (dist < bestd) {\n              a = p[2] - r;\n              if (a < 0) a = -a;\n              dist += a;\n              if (dist < bestd) {\n                bestd = dist;\n                best = p[3];\n              }\n            }\n          }\n        }\n      }\n      return best;\n    }\n    function learn() {\n      var i;\n      var lengthcount = pixels.length;\n      var alphadec = 30 + (samplefac - 1) / 3;\n      var samplepixels = lengthcount / (3 * samplefac);\n      var delta = ~~(samplepixels / ncycles);\n      var alpha = initalpha;\n      var radius = initradius;\n      var rad = radius >> radiusbiasshift;\n      if (rad <= 1) rad = 0;\n      for (i = 0; i < rad; i++) {\n        radpower[i] = alpha * ((rad * rad - i * i) * radbias / (rad * rad));\n      }var step;\n      if (lengthcount < minpicturebytes) {\n        samplefac = 1;\n        step = 3;\n      } else if (lengthcount % prime1 !== 0) {\n        step = 3 * prime1;\n      } else if (lengthcount % prime2 !== 0) {\n        step = 3 * prime2;\n      } else if (lengthcount % prime3 !== 0) {\n        step = 3 * prime3;\n      } else {\n        step = 3 * prime4;\n      }\n      var b, g, r, j;\n      var pix = 0;\n      i = 0;\n      while (i < samplepixels) {\n        b = (pixels[pix] & 255) << netbiasshift;\n        g = (pixels[pix + 1] & 255) << netbiasshift;\n        r = (pixels[pix + 2] & 255) << netbiasshift;\n        j = contest(b, g, r);\n        altersingle(alpha, j, b, g, r);\n        if (rad !== 0) alterneigh(rad, j, b, g, r);\n        pix += step;\n        if (pix >= lengthcount) pix -= lengthcount;\n        i++;\n        if (delta === 0) delta = 1;\n        if (i % delta === 0) {\n          alpha -= alpha / alphadec;\n          radius -= radius / radiusdec;\n          rad = radius >> radiusbiasshift;\n          if (rad <= 1) rad = 0;\n          for (j = 0; j < rad; j++) {\n            radpower[j] = alpha * ((rad * rad - j * j) * radbias / (rad * rad));\n          }\n        }\n      }\n    }\n    function buildColormap() {\n      init();\n      learn();\n      unbiasnet();\n      inxbuild();\n    }\n    this.buildColormap = buildColormap;\n    function getColormap() {\n      var map = [];\n      var index = [];\n      for (var i = 0; i < netsize; i++) {\n        index[network[i][3]] = i;\n      }var k = 0;\n      for (var l = 0; l < netsize; l++) {\n        var j = index[l];\n        map[k++] = network[j][0];\n        map[k++] = network[j][1];\n        map[k++] = network[j][2];\n      }\n      return map;\n    }\n    this.getColormap = getColormap;\n    this.lookupRGB = inxsearch;\n  }\n  var renderFrame;\n  renderFrame = function renderFrame(frame) {\n    var encoder, page, stream, transfer;\n    encoder = new GIFEncoder(frame.width, frame.height);\n    if (frame.index === 0) {\n      encoder.writeHeader();\n    } else {\n      encoder.firstFrame = false;\n    }\n    encoder.setTransparent(frame.transparent);\n    encoder.setRepeat(frame.repeat);\n    encoder.setDelay(frame.delay);\n    encoder.setQuality(frame.quality);\n    encoder.setDither(frame.dither);\n    encoder.setGlobalPalette(frame.globalPalette);\n    encoder.addFrame(frame.data);\n    if (frame.last) {\n      encoder.finish();\n    }\n    if (frame.globalPalette === true) {\n      frame.globalPalette = encoder.getGlobalPalette();\n    }\n    stream = encoder.stream();\n    frame.data = stream.pages;\n    frame.cursor = stream.cursor;\n    frame.pageSize = stream.constructor.pageSize;\n    if (frame.canTransfer) {\n      transfer = function () {\n        var i, len, ref, results;\n        ref = frame.data;\n        results = [];\n        for (i = 0, len = ref.length; i < len; i++) {\n          page = ref[i];\n          results.push(page.buffer);\n        }\n        return results;\n      }();\n      return self.postMessage(frame, transfer);\n    } else {\n      return self.postMessage(frame);\n    }\n  };\n  self.onmessage = function (event) {\n    return renderFrame(event.data);\n  };\n  function ByteArray() {\n    this.page = -1;\n    this.pages = [];\n    this.newPage();\n  }\n  ByteArray.pageSize = 4096;\n  ByteArray.charMap = {};\n  for (var i = 0; i < 256; i++) {\n    ByteArray.charMap[i] = String.fromCharCode(i);\n  }ByteArray.prototype.newPage = function () {\n    this.pages[++this.page] = new Uint8Array(ByteArray.pageSize);\n    this.cursor = 0;\n  };\n  ByteArray.prototype.getData = function () {\n    var rv = \"\";\n    for (var p = 0; p < this.pages.length; p++) {\n      for (var i = 0; i < ByteArray.pageSize; i++) {\n        rv += ByteArray.charMap[this.pages[p][i]];\n      }\n    }\n    return rv;\n  };\n  ByteArray.prototype.writeByte = function (val) {\n    if (this.cursor >= ByteArray.pageSize) this.newPage();\n    this.pages[this.page][this.cursor++] = val;\n  };\n  ByteArray.prototype.writeUTFBytes = function (string) {\n    for (var l = string.length, i = 0; i < l; i++) {\n      this.writeByte(string.charCodeAt(i));\n    }\n  };\n  ByteArray.prototype.writeBytes = function (array, offset, length) {\n    for (var l = length || array.length, i = offset || 0; i < l; i++) {\n      this.writeByte(array[i]);\n    }\n  };\n  function GIFEncoder(width, height) {\n    this.width = ~~width;\n    this.height = ~~height;\n    this.transparent = null;\n    this.transIndex = 0;\n    this.repeat = -1;\n    this.delay = 0;\n    this.image = null;\n    this.pixels = null;\n    this.indexedPixels = null;\n    this.colorDepth = null;\n    this.colorTab = null;\n    this.neuQuant = null;\n    this.usedEntry = new Array();\n    this.palSize = 7;\n    this.dispose = -1;\n    this.firstFrame = true;\n    this.sample = 10;\n    this.dither = false;\n    this.globalPalette = false;\n    this.out = new ByteArray();\n  }\n  GIFEncoder.prototype.setDelay = function (milliseconds) {\n    this.delay = Math.round(milliseconds / 10);\n  };\n  GIFEncoder.prototype.setFrameRate = function (fps) {\n    this.delay = Math.round(100 / fps);\n  };\n  GIFEncoder.prototype.setDispose = function (disposalCode) {\n    if (disposalCode >= 0) this.dispose = disposalCode;\n  };\n  GIFEncoder.prototype.setRepeat = function (repeat) {\n    this.repeat = repeat;\n  };\n  GIFEncoder.prototype.setTransparent = function (color) {\n    this.transparent = color;\n  };\n  GIFEncoder.prototype.addFrame = function (imageData) {\n    this.image = imageData;\n    this.colorTab = this.globalPalette && this.globalPalette.slice ? this.globalPalette : null;\n    this.getImagePixels();\n    this.analyzePixels();\n    if (this.globalPalette === true) this.globalPalette = this.colorTab;\n    if (this.firstFrame) {\n      this.writeLSD();\n      this.writePalette();\n      if (this.repeat >= 0) {\n        this.writeNetscapeExt();\n      }\n    }\n    this.writeGraphicCtrlExt();\n    this.writeImageDesc();\n    if (!this.firstFrame && !this.globalPalette) this.writePalette();\n    this.writePixels();\n    this.firstFrame = false;\n  };\n  GIFEncoder.prototype.finish = function () {\n    this.out.writeByte(59);\n  };\n  GIFEncoder.prototype.setQuality = function (quality) {\n    if (quality < 1) quality = 1;\n    this.sample = quality;\n  };\n  GIFEncoder.prototype.setDither = function (dither) {\n    if (dither === true) dither = \"FloydSteinberg\";\n    this.dither = dither;\n  };\n  GIFEncoder.prototype.setGlobalPalette = function (palette) {\n    this.globalPalette = palette;\n  };\n  GIFEncoder.prototype.getGlobalPalette = function () {\n    return this.globalPalette && this.globalPalette.slice && this.globalPalette.slice(0) || this.globalPalette;\n  };\n  GIFEncoder.prototype.writeHeader = function () {\n    this.out.writeUTFBytes(\"GIF89a\");\n  };\n  GIFEncoder.prototype.analyzePixels = function () {\n    if (!this.colorTab) {\n      this.neuQuant = new NeuQuant(this.pixels, this.sample);\n      this.neuQuant.buildColormap();\n      this.colorTab = this.neuQuant.getColormap();\n    }\n    if (this.dither) {\n      this.ditherPixels(this.dither.replace(\"-serpentine\", \"\"), this.dither.match(/-serpentine/) !== null);\n    } else {\n      this.indexPixels();\n    }\n    this.pixels = null;\n    this.colorDepth = 8;\n    this.palSize = 7;\n    if (this.transparent !== null) {\n      this.transIndex = this.findClosest(this.transparent, true);\n    }\n  };\n  GIFEncoder.prototype.indexPixels = function (imgq) {\n    var nPix = this.pixels.length / 3;\n    this.indexedPixels = new Uint8Array(nPix);\n    var k = 0;\n    for (var j = 0; j < nPix; j++) {\n      var index = this.findClosestRGB(this.pixels[k++] & 255, this.pixels[k++] & 255, this.pixels[k++] & 255);\n      this.usedEntry[index] = true;\n      this.indexedPixels[j] = index;\n    }\n  };\n  GIFEncoder.prototype.ditherPixels = function (kernel, serpentine) {\n    var kernels = {\n      FalseFloydSteinberg: [[3 / 8, 1, 0], [3 / 8, 0, 1], [2 / 8, 1, 1]],\n      FloydSteinberg: [[7 / 16, 1, 0], [3 / 16, -1, 1], [5 / 16, 0, 1], [1 / 16, 1, 1]],\n      Stucki: [[8 / 42, 1, 0], [4 / 42, 2, 0], [2 / 42, -2, 1], [4 / 42, -1, 1], [8 / 42, 0, 1], [4 / 42, 1, 1], [2 / 42, 2, 1], [1 / 42, -2, 2], [2 / 42, -1, 2], [4 / 42, 0, 2], [2 / 42, 1, 2], [1 / 42, 2, 2]],\n      Atkinson: [[1 / 8, 1, 0], [1 / 8, 2, 0], [1 / 8, -1, 1], [1 / 8, 0, 1], [1 / 8, 1, 1], [1 / 8, 0, 2]]\n    };\n    if (!kernel || !kernels[kernel]) {\n      throw \"Unknown dithering kernel: \" + kernel;\n    }\n    var ds = kernels[kernel];\n    var index = 0,\n        height = this.height,\n        width = this.width,\n        data = this.pixels;\n    var direction = serpentine ? -1 : 1;\n    this.indexedPixels = new Uint8Array(this.pixels.length / 3);\n    for (var y = 0; y < height; y++) {\n      if (serpentine) direction = direction * -1;\n      for (var x = direction == 1 ? 0 : width - 1, xend = direction == 1 ? width : 0; x !== xend; x += direction) {\n        index = y * width + x;\n        var idx = index * 3;\n        var r1 = data[idx];\n        var g1 = data[idx + 1];\n        var b1 = data[idx + 2];\n        idx = this.findClosestRGB(r1, g1, b1);\n        this.usedEntry[idx] = true;\n        this.indexedPixels[index] = idx;\n        idx *= 3;\n        var r2 = this.colorTab[idx];\n        var g2 = this.colorTab[idx + 1];\n        var b2 = this.colorTab[idx + 2];\n        var er = r1 - r2;\n        var eg = g1 - g2;\n        var eb = b1 - b2;\n        for (var i = direction == 1 ? 0 : ds.length - 1, end = direction == 1 ? ds.length : 0; i !== end; i += direction) {\n          var x1 = ds[i][1];\n          var y1 = ds[i][2];\n          if (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {\n            var d = ds[i][0];\n            idx = index + x1 + y1 * width;\n            idx *= 3;\n            data[idx] = Math.max(0, Math.min(255, data[idx] + er * d));\n            data[idx + 1] = Math.max(0, Math.min(255, data[idx + 1] + eg * d));\n            data[idx + 2] = Math.max(0, Math.min(255, data[idx + 2] + eb * d));\n          }\n        }\n      }\n    }\n  };\n  GIFEncoder.prototype.findClosest = function (c, used) {\n    return this.findClosestRGB((c & 16711680) >> 16, (c & 65280) >> 8, c & 255, used);\n  };\n  GIFEncoder.prototype.findClosestRGB = function (r, g, b, used) {\n    if (this.colorTab === null) return -1;\n    if (this.neuQuant && !used) {\n      return this.neuQuant.lookupRGB(r, g, b);\n    }\n    var c = b | g << 8 | r << 16;\n    var minpos = 0;\n    var dmin = 256 * 256 * 256;\n    var len = this.colorTab.length;\n    for (var i = 0, index = 0; i < len; index++) {\n      var dr = r - (this.colorTab[i++] & 255);\n      var dg = g - (this.colorTab[i++] & 255);\n      var db = b - (this.colorTab[i++] & 255);\n      var d = dr * dr + dg * dg + db * db;\n      if ((!used || this.usedEntry[index]) && d < dmin) {\n        dmin = d;\n        minpos = index;\n      }\n    }\n    return minpos;\n  };\n  GIFEncoder.prototype.getImagePixels = function () {\n    var w = this.width;\n    var h = this.height;\n    this.pixels = new Uint8Array(w * h * 3);\n    var data = this.image;\n    var srcPos = 0;\n    var count = 0;\n    for (var i = 0; i < h; i++) {\n      for (var j = 0; j < w; j++) {\n        this.pixels[count++] = data[srcPos++];\n        this.pixels[count++] = data[srcPos++];\n        this.pixels[count++] = data[srcPos++];\n        srcPos++;\n      }\n    }\n  };\n  GIFEncoder.prototype.writeGraphicCtrlExt = function () {\n    this.out.writeByte(33);\n    this.out.writeByte(249);\n    this.out.writeByte(4);\n    var transp, disp;\n    if (this.transparent === null) {\n      transp = 0;\n      disp = 0;\n    } else {\n      transp = 1;\n      disp = 2;\n    }\n    if (this.dispose >= 0) {\n      disp = dispose & 7;\n    }\n    disp <<= 2;\n    this.out.writeByte(0 | disp | 0 | transp);\n    this.writeShort(this.delay);\n    this.out.writeByte(this.transIndex);\n    this.out.writeByte(0);\n  };\n  GIFEncoder.prototype.writeImageDesc = function () {\n    this.out.writeByte(44);\n    this.writeShort(0);\n    this.writeShort(0);\n    this.writeShort(this.width);\n    this.writeShort(this.height);\n    if (this.firstFrame || this.globalPalette) {\n      this.out.writeByte(0);\n    } else {\n      this.out.writeByte(128 | 0 | 0 | 0 | this.palSize);\n    }\n  };\n  GIFEncoder.prototype.writeLSD = function () {\n    this.writeShort(this.width);\n    this.writeShort(this.height);\n    this.out.writeByte(128 | 112 | 0 | this.palSize);\n    this.out.writeByte(0);\n    this.out.writeByte(0);\n  };\n  GIFEncoder.prototype.writeNetscapeExt = function () {\n    this.out.writeByte(33);\n    this.out.writeByte(255);\n    this.out.writeByte(11);\n    this.out.writeUTFBytes(\"NETSCAPE2.0\");\n    this.out.writeByte(3);\n    this.out.writeByte(1);\n    this.writeShort(this.repeat);\n    this.out.writeByte(0);\n  };\n  GIFEncoder.prototype.writePalette = function () {\n    this.out.writeBytes(this.colorTab);\n    var n = 3 * 256 - this.colorTab.length;\n    for (var i = 0; i < n; i++) {\n      this.out.writeByte(0);\n    }\n  };\n  GIFEncoder.prototype.writeShort = function (pValue) {\n    this.out.writeByte(pValue & 255);\n    this.out.writeByte(pValue >> 8 & 255);\n  };\n  GIFEncoder.prototype.writePixels = function () {\n    var enc = new LZWEncoder(this.width, this.height, this.indexedPixels, this.colorDepth);\n    enc.encode(this.out);\n  };\n  GIFEncoder.prototype.stream = function () {\n    return this.out;\n  };\n}();\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// 7340f9193e3b24ac5930.worker.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7340f9193e3b24ac5930","~(function() {\n  var EOF = -1;\n  var BITS = 12;\n  var HSIZE = 5003;\n  var masks = [\n    0,\n    1,\n    3,\n    7,\n    15,\n    31,\n    63,\n    127,\n    255,\n    511,\n    1023,\n    2047,\n    4095,\n    8191,\n    16383,\n    32767,\n    65535\n  ];\n  var remaining, curPixel, n_bits;\n  function LZWEncoder(width, height, pixels, colorDepth) {\n    var initCodeSize = Math.max(2, colorDepth);\n    var accum = new Uint8Array(256);\n    var htab = new Int32Array(HSIZE);\n    var codetab = new Int32Array(HSIZE);\n    var cur_accum,\n      cur_bits = 0;\n    var a_count;\n    var free_ent = 0;\n    var maxcode;\n    var clear_flg = false;\n    var g_init_bits, ClearCode, EOFCode;\n    function char_out(c, outs) {\n      accum[a_count++] = c;\n      if (a_count >= 254) flush_char(outs);\n    }\n    function cl_block(outs) {\n      cl_hash(HSIZE);\n      free_ent = ClearCode + 2;\n      clear_flg = true;\n      output(ClearCode, outs);\n    }\n    function cl_hash(hsize) {\n      for (var i = 0; i < hsize; ++i) htab[i] = -1;\n    }\n    function compress(init_bits, outs) {\n      var fcode, c, i, ent, disp, hsize_reg, hshift;\n      g_init_bits = init_bits;\n      clear_flg = false;\n      n_bits = g_init_bits;\n      maxcode = MAXCODE(n_bits);\n      ClearCode = 1 << (init_bits - 1);\n      EOFCode = ClearCode + 1;\n      free_ent = ClearCode + 2;\n      a_count = 0;\n      ent = nextPixel();\n      hshift = 0;\n      for (fcode = HSIZE; fcode < 65536; fcode *= 2) ++hshift;\n      hshift = 8 - hshift;\n      hsize_reg = HSIZE;\n      cl_hash(hsize_reg);\n      output(ClearCode, outs);\n      outer_loop: while ((c = nextPixel()) != EOF) {\n        fcode = (c << BITS) + ent;\n        i = (c << hshift) ^ ent;\n        if (htab[i] === fcode) {\n          ent = codetab[i];\n          continue;\n        } else if (htab[i] >= 0) {\n          disp = hsize_reg - i;\n          if (i === 0) disp = 1;\n          do {\n            if ((i -= disp) < 0) i += hsize_reg;\n            if (htab[i] === fcode) {\n              ent = codetab[i];\n              continue outer_loop;\n            }\n          } while (htab[i] >= 0);\n        }\n        output(ent, outs);\n        ent = c;\n        if (free_ent < 1 << BITS) {\n          codetab[i] = free_ent++;\n          htab[i] = fcode;\n        } else {\n          cl_block(outs);\n        }\n      }\n      output(ent, outs);\n      output(EOFCode, outs);\n    }\n    function encode(outs) {\n      outs.writeByte(initCodeSize);\n      remaining = width * height;\n      curPixel = 0;\n      compress(initCodeSize + 1, outs);\n      outs.writeByte(0);\n    }\n    function flush_char(outs) {\n      if (a_count > 0) {\n        outs.writeByte(a_count);\n        outs.writeBytes(accum, 0, a_count);\n        a_count = 0;\n      }\n    }\n    function MAXCODE(n_bits) {\n      return (1 << n_bits) - 1;\n    }\n    function nextPixel() {\n      if (remaining === 0) return EOF;\n      --remaining;\n      var pix = pixels[curPixel++];\n      return pix & 255;\n    }\n    function output(code, outs) {\n      cur_accum &= masks[cur_bits];\n      if (cur_bits > 0) cur_accum |= code << cur_bits;\n      else cur_accum = code;\n      cur_bits += n_bits;\n      while (cur_bits >= 8) {\n        char_out(cur_accum & 255, outs);\n        cur_accum >>= 8;\n        cur_bits -= 8;\n      }\n      if (free_ent > maxcode || clear_flg) {\n        if (clear_flg) {\n          maxcode = MAXCODE((n_bits = g_init_bits));\n          clear_flg = false;\n        } else {\n          ++n_bits;\n          if (n_bits == BITS) maxcode = 1 << BITS;\n          else maxcode = MAXCODE(n_bits);\n        }\n      }\n      if (code == EOFCode) {\n        while (cur_bits > 0) {\n          char_out(cur_accum & 255, outs);\n          cur_accum >>= 8;\n          cur_bits -= 8;\n        }\n        flush_char(outs);\n      }\n    }\n    this.encode = encode;\n  }\n  var ncycles = 100;\n  var netsize = 256;\n  var maxnetpos = netsize - 1;\n  var netbiasshift = 4;\n  var intbiasshift = 16;\n  var intbias = 1 << intbiasshift;\n  var gammashift = 10;\n  var gamma = 1 << gammashift;\n  var betashift = 10;\n  var beta = intbias >> betashift;\n  var betagamma = intbias << (gammashift - betashift);\n  var initrad = netsize >> 3;\n  var radiusbiasshift = 6;\n  var radiusbias = 1 << radiusbiasshift;\n  var initradius = initrad * radiusbias;\n  var radiusdec = 30;\n  var alphabiasshift = 10;\n  var initalpha = 1 << alphabiasshift;\n  var alphadec;\n  var radbiasshift = 8;\n  var radbias = 1 << radbiasshift;\n  var alpharadbshift = alphabiasshift + radbiasshift;\n  var alpharadbias = 1 << alpharadbshift;\n  var prime1 = 499;\n  var prime2 = 491;\n  var prime3 = 487;\n  var prime4 = 503;\n  var minpicturebytes = 3 * prime4;\n  function NeuQuant(pixels, samplefac) {\n    var network;\n    var netindex;\n    var bias;\n    var freq;\n    var radpower;\n    function init() {\n      network = [];\n      netindex = new Int32Array(256);\n      bias = new Int32Array(netsize);\n      freq = new Int32Array(netsize);\n      radpower = new Int32Array(netsize >> 3);\n      var i, v;\n      for (i = 0; i < netsize; i++) {\n        v = (i << (netbiasshift + 8)) / netsize;\n        network[i] = new Float64Array([v, v, v, 0]);\n        freq[i] = intbias / netsize;\n        bias[i] = 0;\n      }\n    }\n    function unbiasnet() {\n      for (var i = 0; i < netsize; i++) {\n        network[i][0] >>= netbiasshift;\n        network[i][1] >>= netbiasshift;\n        network[i][2] >>= netbiasshift;\n        network[i][3] = i;\n      }\n    }\n    function altersingle(alpha, i, b, g, r) {\n      network[i][0] -= (alpha * (network[i][0] - b)) / initalpha;\n      network[i][1] -= (alpha * (network[i][1] - g)) / initalpha;\n      network[i][2] -= (alpha * (network[i][2] - r)) / initalpha;\n    }\n    function alterneigh(radius, i, b, g, r) {\n      var lo = Math.abs(i - radius);\n      var hi = Math.min(i + radius, netsize);\n      var j = i + 1;\n      var k = i - 1;\n      var m = 1;\n      var p, a;\n      while (j < hi || k > lo) {\n        a = radpower[m++];\n        if (j < hi) {\n          p = network[j++];\n          p[0] -= (a * (p[0] - b)) / alpharadbias;\n          p[1] -= (a * (p[1] - g)) / alpharadbias;\n          p[2] -= (a * (p[2] - r)) / alpharadbias;\n        }\n        if (k > lo) {\n          p = network[k--];\n          p[0] -= (a * (p[0] - b)) / alpharadbias;\n          p[1] -= (a * (p[1] - g)) / alpharadbias;\n          p[2] -= (a * (p[2] - r)) / alpharadbias;\n        }\n      }\n    }\n    function contest(b, g, r) {\n      var bestd = ~(1 << 31);\n      var bestbiasd = bestd;\n      var bestpos = -1;\n      var bestbiaspos = bestpos;\n      var i, n, dist, biasdist, betafreq;\n      for (i = 0; i < netsize; i++) {\n        n = network[i];\n        dist = Math.abs(n[0] - b) + Math.abs(n[1] - g) + Math.abs(n[2] - r);\n        if (dist < bestd) {\n          bestd = dist;\n          bestpos = i;\n        }\n        biasdist = dist - (bias[i] >> (intbiasshift - netbiasshift));\n        if (biasdist < bestbiasd) {\n          bestbiasd = biasdist;\n          bestbiaspos = i;\n        }\n        betafreq = freq[i] >> betashift;\n        freq[i] -= betafreq;\n        bias[i] += betafreq << gammashift;\n      }\n      freq[bestpos] += beta;\n      bias[bestpos] -= betagamma;\n      return bestbiaspos;\n    }\n    function inxbuild() {\n      var i,\n        j,\n        p,\n        q,\n        smallpos,\n        smallval,\n        previouscol = 0,\n        startpos = 0;\n      for (i = 0; i < netsize; i++) {\n        p = network[i];\n        smallpos = i;\n        smallval = p[1];\n        for (j = i + 1; j < netsize; j++) {\n          q = network[j];\n          if (q[1] < smallval) {\n            smallpos = j;\n            smallval = q[1];\n          }\n        }\n        q = network[smallpos];\n        if (i != smallpos) {\n          j = q[0];\n          q[0] = p[0];\n          p[0] = j;\n          j = q[1];\n          q[1] = p[1];\n          p[1] = j;\n          j = q[2];\n          q[2] = p[2];\n          p[2] = j;\n          j = q[3];\n          q[3] = p[3];\n          p[3] = j;\n        }\n        if (smallval != previouscol) {\n          netindex[previouscol] = (startpos + i) >> 1;\n          for (j = previouscol + 1; j < smallval; j++) netindex[j] = i;\n          previouscol = smallval;\n          startpos = i;\n        }\n      }\n      netindex[previouscol] = (startpos + maxnetpos) >> 1;\n      for (j = previouscol + 1; j < 256; j++) netindex[j] = maxnetpos;\n    }\n    function inxsearch(b, g, r) {\n      var a, p, dist;\n      var bestd = 1e3;\n      var best = -1;\n      var i = netindex[g];\n      var j = i - 1;\n      while (i < netsize || j >= 0) {\n        if (i < netsize) {\n          p = network[i];\n          dist = p[1] - g;\n          if (dist >= bestd) i = netsize;\n          else {\n            i++;\n            if (dist < 0) dist = -dist;\n            a = p[0] - b;\n            if (a < 0) a = -a;\n            dist += a;\n            if (dist < bestd) {\n              a = p[2] - r;\n              if (a < 0) a = -a;\n              dist += a;\n              if (dist < bestd) {\n                bestd = dist;\n                best = p[3];\n              }\n            }\n          }\n        }\n        if (j >= 0) {\n          p = network[j];\n          dist = g - p[1];\n          if (dist >= bestd) j = -1;\n          else {\n            j--;\n            if (dist < 0) dist = -dist;\n            a = p[0] - b;\n            if (a < 0) a = -a;\n            dist += a;\n            if (dist < bestd) {\n              a = p[2] - r;\n              if (a < 0) a = -a;\n              dist += a;\n              if (dist < bestd) {\n                bestd = dist;\n                best = p[3];\n              }\n            }\n          }\n        }\n      }\n      return best;\n    }\n    function learn() {\n      var i;\n      var lengthcount = pixels.length;\n      var alphadec = 30 + (samplefac - 1) / 3;\n      var samplepixels = lengthcount / (3 * samplefac);\n      var delta = ~~(samplepixels / ncycles);\n      var alpha = initalpha;\n      var radius = initradius;\n      var rad = radius >> radiusbiasshift;\n      if (rad <= 1) rad = 0;\n      for (i = 0; i < rad; i++)\n        radpower[i] = alpha * (((rad * rad - i * i) * radbias) / (rad * rad));\n      var step;\n      if (lengthcount < minpicturebytes) {\n        samplefac = 1;\n        step = 3;\n      } else if (lengthcount % prime1 !== 0) {\n        step = 3 * prime1;\n      } else if (lengthcount % prime2 !== 0) {\n        step = 3 * prime2;\n      } else if (lengthcount % prime3 !== 0) {\n        step = 3 * prime3;\n      } else {\n        step = 3 * prime4;\n      }\n      var b, g, r, j;\n      var pix = 0;\n      i = 0;\n      while (i < samplepixels) {\n        b = (pixels[pix] & 255) << netbiasshift;\n        g = (pixels[pix + 1] & 255) << netbiasshift;\n        r = (pixels[pix + 2] & 255) << netbiasshift;\n        j = contest(b, g, r);\n        altersingle(alpha, j, b, g, r);\n        if (rad !== 0) alterneigh(rad, j, b, g, r);\n        pix += step;\n        if (pix >= lengthcount) pix -= lengthcount;\n        i++;\n        if (delta === 0) delta = 1;\n        if (i % delta === 0) {\n          alpha -= alpha / alphadec;\n          radius -= radius / radiusdec;\n          rad = radius >> radiusbiasshift;\n          if (rad <= 1) rad = 0;\n          for (j = 0; j < rad; j++)\n            radpower[j] =\n              alpha * (((rad * rad - j * j) * radbias) / (rad * rad));\n        }\n      }\n    }\n    function buildColormap() {\n      init();\n      learn();\n      unbiasnet();\n      inxbuild();\n    }\n    this.buildColormap = buildColormap;\n    function getColormap() {\n      var map = [];\n      var index = [];\n      for (var i = 0; i < netsize; i++) index[network[i][3]] = i;\n      var k = 0;\n      for (var l = 0; l < netsize; l++) {\n        var j = index[l];\n        map[k++] = network[j][0];\n        map[k++] = network[j][1];\n        map[k++] = network[j][2];\n      }\n      return map;\n    }\n    this.getColormap = getColormap;\n    this.lookupRGB = inxsearch;\n  }\n  var renderFrame;\n  renderFrame = function(frame) {\n    var encoder, page, stream, transfer;\n    encoder = new GIFEncoder(frame.width, frame.height);\n    if (frame.index === 0) {\n      encoder.writeHeader();\n    } else {\n      encoder.firstFrame = false;\n    }\n    encoder.setTransparent(frame.transparent);\n    encoder.setRepeat(frame.repeat);\n    encoder.setDelay(frame.delay);\n    encoder.setQuality(frame.quality);\n    encoder.setDither(frame.dither);\n    encoder.setGlobalPalette(frame.globalPalette);\n    encoder.addFrame(frame.data);\n    if (frame.last) {\n      encoder.finish();\n    }\n    if (frame.globalPalette === true) {\n      frame.globalPalette = encoder.getGlobalPalette();\n    }\n    stream = encoder.stream();\n    frame.data = stream.pages;\n    frame.cursor = stream.cursor;\n    frame.pageSize = stream.constructor.pageSize;\n    if (frame.canTransfer) {\n      transfer = (function() {\n        var i, len, ref, results;\n        ref = frame.data;\n        results = [];\n        for (i = 0, len = ref.length; i < len; i++) {\n          page = ref[i];\n          results.push(page.buffer);\n        }\n        return results;\n      })();\n      return self.postMessage(frame, transfer);\n    } else {\n      return self.postMessage(frame);\n    }\n  };\n  self.onmessage = function(event) {\n    return renderFrame(event.data);\n  };\n  function ByteArray() {\n    this.page = -1;\n    this.pages = [];\n    this.newPage();\n  }\n  ByteArray.pageSize = 4096;\n  ByteArray.charMap = {};\n  for (var i = 0; i < 256; i++) ByteArray.charMap[i] = String.fromCharCode(i);\n  ByteArray.prototype.newPage = function() {\n    this.pages[++this.page] = new Uint8Array(ByteArray.pageSize);\n    this.cursor = 0;\n  };\n  ByteArray.prototype.getData = function() {\n    var rv = \"\";\n    for (var p = 0; p < this.pages.length; p++) {\n      for (var i = 0; i < ByteArray.pageSize; i++) {\n        rv += ByteArray.charMap[this.pages[p][i]];\n      }\n    }\n    return rv;\n  };\n  ByteArray.prototype.writeByte = function(val) {\n    if (this.cursor >= ByteArray.pageSize) this.newPage();\n    this.pages[this.page][this.cursor++] = val;\n  };\n  ByteArray.prototype.writeUTFBytes = function(string) {\n    for (var l = string.length, i = 0; i < l; i++)\n      this.writeByte(string.charCodeAt(i));\n  };\n  ByteArray.prototype.writeBytes = function(array, offset, length) {\n    for (var l = length || array.length, i = offset || 0; i < l; i++)\n      this.writeByte(array[i]);\n  };\n  function GIFEncoder(width, height) {\n    this.width = ~~width;\n    this.height = ~~height;\n    this.transparent = null;\n    this.transIndex = 0;\n    this.repeat = -1;\n    this.delay = 0;\n    this.image = null;\n    this.pixels = null;\n    this.indexedPixels = null;\n    this.colorDepth = null;\n    this.colorTab = null;\n    this.neuQuant = null;\n    this.usedEntry = new Array();\n    this.palSize = 7;\n    this.dispose = -1;\n    this.firstFrame = true;\n    this.sample = 10;\n    this.dither = false;\n    this.globalPalette = false;\n    this.out = new ByteArray();\n  }\n  GIFEncoder.prototype.setDelay = function(milliseconds) {\n    this.delay = Math.round(milliseconds / 10);\n  };\n  GIFEncoder.prototype.setFrameRate = function(fps) {\n    this.delay = Math.round(100 / fps);\n  };\n  GIFEncoder.prototype.setDispose = function(disposalCode) {\n    if (disposalCode >= 0) this.dispose = disposalCode;\n  };\n  GIFEncoder.prototype.setRepeat = function(repeat) {\n    this.repeat = repeat;\n  };\n  GIFEncoder.prototype.setTransparent = function(color) {\n    this.transparent = color;\n  };\n  GIFEncoder.prototype.addFrame = function(imageData) {\n    this.image = imageData;\n    this.colorTab =\n      this.globalPalette && this.globalPalette.slice\n        ? this.globalPalette\n        : null;\n    this.getImagePixels();\n    this.analyzePixels();\n    if (this.globalPalette === true) this.globalPalette = this.colorTab;\n    if (this.firstFrame) {\n      this.writeLSD();\n      this.writePalette();\n      if (this.repeat >= 0) {\n        this.writeNetscapeExt();\n      }\n    }\n    this.writeGraphicCtrlExt();\n    this.writeImageDesc();\n    if (!this.firstFrame && !this.globalPalette) this.writePalette();\n    this.writePixels();\n    this.firstFrame = false;\n  };\n  GIFEncoder.prototype.finish = function() {\n    this.out.writeByte(59);\n  };\n  GIFEncoder.prototype.setQuality = function(quality) {\n    if (quality < 1) quality = 1;\n    this.sample = quality;\n  };\n  GIFEncoder.prototype.setDither = function(dither) {\n    if (dither === true) dither = \"FloydSteinberg\";\n    this.dither = dither;\n  };\n  GIFEncoder.prototype.setGlobalPalette = function(palette) {\n    this.globalPalette = palette;\n  };\n  GIFEncoder.prototype.getGlobalPalette = function() {\n    return (\n      (this.globalPalette &&\n        this.globalPalette.slice &&\n        this.globalPalette.slice(0)) ||\n      this.globalPalette\n    );\n  };\n  GIFEncoder.prototype.writeHeader = function() {\n    this.out.writeUTFBytes(\"GIF89a\");\n  };\n  GIFEncoder.prototype.analyzePixels = function() {\n    if (!this.colorTab) {\n      this.neuQuant = new NeuQuant(this.pixels, this.sample);\n      this.neuQuant.buildColormap();\n      this.colorTab = this.neuQuant.getColormap();\n    }\n    if (this.dither) {\n      this.ditherPixels(\n        this.dither.replace(\"-serpentine\", \"\"),\n        this.dither.match(/-serpentine/) !== null\n      );\n    } else {\n      this.indexPixels();\n    }\n    this.pixels = null;\n    this.colorDepth = 8;\n    this.palSize = 7;\n    if (this.transparent !== null) {\n      this.transIndex = this.findClosest(this.transparent, true);\n    }\n  };\n  GIFEncoder.prototype.indexPixels = function(imgq) {\n    var nPix = this.pixels.length / 3;\n    this.indexedPixels = new Uint8Array(nPix);\n    var k = 0;\n    for (var j = 0; j < nPix; j++) {\n      var index = this.findClosestRGB(\n        this.pixels[k++] & 255,\n        this.pixels[k++] & 255,\n        this.pixels[k++] & 255\n      );\n      this.usedEntry[index] = true;\n      this.indexedPixels[j] = index;\n    }\n  };\n  GIFEncoder.prototype.ditherPixels = function(kernel, serpentine) {\n    var kernels = {\n      FalseFloydSteinberg: [[3 / 8, 1, 0], [3 / 8, 0, 1], [2 / 8, 1, 1]],\n      FloydSteinberg: [\n        [7 / 16, 1, 0],\n        [3 / 16, -1, 1],\n        [5 / 16, 0, 1],\n        [1 / 16, 1, 1]\n      ],\n      Stucki: [\n        [8 / 42, 1, 0],\n        [4 / 42, 2, 0],\n        [2 / 42, -2, 1],\n        [4 / 42, -1, 1],\n        [8 / 42, 0, 1],\n        [4 / 42, 1, 1],\n        [2 / 42, 2, 1],\n        [1 / 42, -2, 2],\n        [2 / 42, -1, 2],\n        [4 / 42, 0, 2],\n        [2 / 42, 1, 2],\n        [1 / 42, 2, 2]\n      ],\n      Atkinson: [\n        [1 / 8, 1, 0],\n        [1 / 8, 2, 0],\n        [1 / 8, -1, 1],\n        [1 / 8, 0, 1],\n        [1 / 8, 1, 1],\n        [1 / 8, 0, 2]\n      ]\n    };\n    if (!kernel || !kernels[kernel]) {\n      throw \"Unknown dithering kernel: \" + kernel;\n    }\n    var ds = kernels[kernel];\n    var index = 0,\n      height = this.height,\n      width = this.width,\n      data = this.pixels;\n    var direction = serpentine ? -1 : 1;\n    this.indexedPixels = new Uint8Array(this.pixels.length / 3);\n    for (var y = 0; y < height; y++) {\n      if (serpentine) direction = direction * -1;\n      for (\n        var x = direction == 1 ? 0 : width - 1,\n          xend = direction == 1 ? width : 0;\n        x !== xend;\n        x += direction\n      ) {\n        index = y * width + x;\n        var idx = index * 3;\n        var r1 = data[idx];\n        var g1 = data[idx + 1];\n        var b1 = data[idx + 2];\n        idx = this.findClosestRGB(r1, g1, b1);\n        this.usedEntry[idx] = true;\n        this.indexedPixels[index] = idx;\n        idx *= 3;\n        var r2 = this.colorTab[idx];\n        var g2 = this.colorTab[idx + 1];\n        var b2 = this.colorTab[idx + 2];\n        var er = r1 - r2;\n        var eg = g1 - g2;\n        var eb = b1 - b2;\n        for (\n          var i = direction == 1 ? 0 : ds.length - 1,\n            end = direction == 1 ? ds.length : 0;\n          i !== end;\n          i += direction\n        ) {\n          var x1 = ds[i][1];\n          var y1 = ds[i][2];\n          if (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {\n            var d = ds[i][0];\n            idx = index + x1 + y1 * width;\n            idx *= 3;\n            data[idx] = Math.max(0, Math.min(255, data[idx] + er * d));\n            data[idx + 1] = Math.max(0, Math.min(255, data[idx + 1] + eg * d));\n            data[idx + 2] = Math.max(0, Math.min(255, data[idx + 2] + eb * d));\n          }\n        }\n      }\n    }\n  };\n  GIFEncoder.prototype.findClosest = function(c, used) {\n    return this.findClosestRGB(\n      (c & 16711680) >> 16,\n      (c & 65280) >> 8,\n      c & 255,\n      used\n    );\n  };\n  GIFEncoder.prototype.findClosestRGB = function(r, g, b, used) {\n    if (this.colorTab === null) return -1;\n    if (this.neuQuant && !used) {\n      return this.neuQuant.lookupRGB(r, g, b);\n    }\n    var c = b | (g << 8) | (r << 16);\n    var minpos = 0;\n    var dmin = 256 * 256 * 256;\n    var len = this.colorTab.length;\n    for (var i = 0, index = 0; i < len; index++) {\n      var dr = r - (this.colorTab[i++] & 255);\n      var dg = g - (this.colorTab[i++] & 255);\n      var db = b - (this.colorTab[i++] & 255);\n      var d = dr * dr + dg * dg + db * db;\n      if ((!used || this.usedEntry[index]) && d < dmin) {\n        dmin = d;\n        minpos = index;\n      }\n    }\n    return minpos;\n  };\n  GIFEncoder.prototype.getImagePixels = function() {\n    var w = this.width;\n    var h = this.height;\n    this.pixels = new Uint8Array(w * h * 3);\n    var data = this.image;\n    var srcPos = 0;\n    var count = 0;\n    for (var i = 0; i < h; i++) {\n      for (var j = 0; j < w; j++) {\n        this.pixels[count++] = data[srcPos++];\n        this.pixels[count++] = data[srcPos++];\n        this.pixels[count++] = data[srcPos++];\n        srcPos++;\n      }\n    }\n  };\n  GIFEncoder.prototype.writeGraphicCtrlExt = function() {\n    this.out.writeByte(33);\n    this.out.writeByte(249);\n    this.out.writeByte(4);\n    var transp, disp;\n    if (this.transparent === null) {\n      transp = 0;\n      disp = 0;\n    } else {\n      transp = 1;\n      disp = 2;\n    }\n    if (this.dispose >= 0) {\n      disp = dispose & 7;\n    }\n    disp <<= 2;\n    this.out.writeByte(0 | disp | 0 | transp);\n    this.writeShort(this.delay);\n    this.out.writeByte(this.transIndex);\n    this.out.writeByte(0);\n  };\n  GIFEncoder.prototype.writeImageDesc = function() {\n    this.out.writeByte(44);\n    this.writeShort(0);\n    this.writeShort(0);\n    this.writeShort(this.width);\n    this.writeShort(this.height);\n    if (this.firstFrame || this.globalPalette) {\n      this.out.writeByte(0);\n    } else {\n      this.out.writeByte(128 | 0 | 0 | 0 | this.palSize);\n    }\n  };\n  GIFEncoder.prototype.writeLSD = function() {\n    this.writeShort(this.width);\n    this.writeShort(this.height);\n    this.out.writeByte(128 | 112 | 0 | this.palSize);\n    this.out.writeByte(0);\n    this.out.writeByte(0);\n  };\n  GIFEncoder.prototype.writeNetscapeExt = function() {\n    this.out.writeByte(33);\n    this.out.writeByte(255);\n    this.out.writeByte(11);\n    this.out.writeUTFBytes(\"NETSCAPE2.0\");\n    this.out.writeByte(3);\n    this.out.writeByte(1);\n    this.writeShort(this.repeat);\n    this.out.writeByte(0);\n  };\n  GIFEncoder.prototype.writePalette = function() {\n    this.out.writeBytes(this.colorTab);\n    var n = 3 * 256 - this.colorTab.length;\n    for (var i = 0; i < n; i++) this.out.writeByte(0);\n  };\n  GIFEncoder.prototype.writeShort = function(pValue) {\n    this.out.writeByte(pValue & 255);\n    this.out.writeByte((pValue >> 8) & 255);\n  };\n  GIFEncoder.prototype.writePixels = function() {\n    var enc = new LZWEncoder(\n      this.width,\n      this.height,\n      this.indexedPixels,\n      this.colorDepth\n    );\n    enc.encode(this.out);\n  };\n  GIFEncoder.prototype.stream = function() {\n    return this.out;\n  };\n})();\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/gif.worker.js"],"sourceRoot":""}